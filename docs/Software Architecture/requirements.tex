\documentclass[a4paper,10pt]{article}

\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[all]{hypcap}
\usepackage{tabu}
\usepackage[title,titletoc,toc]{appendix}
\usepackage[english]{babel}
\usepackage{fontspec}
\usepackage[style=authoryear,backend=biber,sorting=nyt,dashed=false,urldate=long,abbreviate=false]{biblatex}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{microtype}

\addbibresource{references.bib}

\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{\bfseries Software Architecture Specification}
\lfoot{Team Echo}
\cfoot{COS301 Software Engineering}
\rfoot{Page \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\frenchspacing

\title{\includegraphics[width=12cm]{Eeufeeslogo.jpg} \\
       Software Architecture \\
       Research Paper Management System \\
       \vspace{0.5cm}
       University of Pretoria \\
       \vspace{1.0cm}
       }

\date{} 
\author{Team Echo\\
	\vspace{0.5cm} \\
	\begin{tabu} to \textwidth { X[l] X[l]}
		\hline
		\textbf{Surname, First Name (Initial)}	& \textbf{Student Number}	\\ \hline \hline
		Bode, Elizabeth (EF)			& 14310156		\\ \hline
		Bondjobo, Jocelyn (JM)		& 13232852		\\ \hline
		Broekman, Andrew (A)		& 11089777		\\ \hline
		Loreggian, Fabio (FR)			& 14040426		\\ \hline
		Schutte, Gerome (GC)		& 12031519		\\ \hline
		Sefako, Motsitsiripe (MG)		& 12231097		\\ \hline
		Singh, Emilio (E)			& 14006512		\\ \hline
		\hline
	\end{tabu}}

\DefineBibliographyStrings{english}{%
urlseen = {\mbox{Accessed} on},
urlfrom = {[Online]},
in = {In},
}
\DeclareFieldFormat{url}{\bibstring{urlfrom}\space\url{#1}}
\DeclareFieldFormat{urldate}{\addcomma\space[\bibstring{urlseen}\space#1]}
\addto\captionsenglish{
  \renewcommand{\contentsname}
    {Table of Contents}
}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\tableofcontents
\clearpage

\newpage
\pagenumbering{arabic}

\section{Architecture requirements}
\subsection{Architectural scope}
\subsection{Quality requirements}
	\subsubsection{Performance}
		\begin{enumerate}
			\item \textbf{Description} \\
				Application performance can be defined as the amount of work that can be accomplished by an application in question in a measured time interval. The time interval is normally measured in seconds, where the amount of work can be defined as the throughput, latency or data transmission time.
				\begin{itemize}
					\item \textbf{Throughput} \\
					The number of requests and responses which can be processed by the system in a given time interval.
					\item \textbf{Latency} \\
					A time interval measured as the time it takes to service a request.
					\item \textbf{Data transmission time} \\
					The time it takes to transmit a request to the server from a client or a response from the server to the client. This is heavily influenced by the size of the request, as well as the quality of the network medium.
				\end{itemize}

				The aim for this system, is to increase the throughput and decrease the latency. As the developer has no control over the network medium used, he/she must aim for a minimal request and response payload as to decrease the data transmission time.

			\item \textbf{Justification} \\
				The current system suffers from performance issues, and hence, it is important for this new system to address these issues adequately. Our aim for this system is to increase throughput, decrease latency and data transmission time. This will ensure we have a system that is responsive at all times, including peak times and delivers an excellent user experience.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item Network requests must be benchmarked, monitored and aggregate statistics about network requests must be made available.
					\item Function calls must be timed and benchmarked and this data should be logged.
					\item Precompiled SQL must be used in statements.
					\item Network responses should be cached on server side to lighten the load on database as well as decreasing the round trip time of request - response.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Reliability}
		\begin{enumerate}
			\item \textbf{Description} \\
				The design of this system is largely based on the fact that the current system used by the client is not reliable and suffers from system crashes and data loss. The newly designed system needs to be accessible from both inside University of Pretoria campuses as well as from other networks, especially on other campuses on the TENET network. The system should be reliable in both its accessibility and in the data that the system will use to calculate contributor metrics. 

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Scalability}
		\begin{enumerate}
			\item \textbf{Description} \\
				Scalability refers to the application in question's ability to handle an above normal workload for extended time periods and the mechanisms employed to facilitate this. The client has specified minimum conditions under which the system needs to function. However, the client has indicated that due to the business requirements, the system will experience higher workloads during the end of the month.

			\item \textbf{Justification} \\
				The system needs Scalability because it needs to support 10 research groups, with 100 members each working with 50 concurrent users. But these requirements may increase in future and hence the system should be able to handle additional loads.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item The system should be able to handle 10 research groups with each research group containing 100 members.
					\item The system should be able to facilitate 50 concurrent user sessions at any time.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Security}
		\begin{enumerate}
			\item \textbf{Description} \\
				Security in application software refers to authentication, authorization, data security and accounting. Authentication refers to the systems' ability to provide a way of identifying a user, normally with a combination of a user name and password, or by using access tokens. Authorization refers to the systems' ability to determine whether the user in question has the required authority to execute certain commands or tasks. Data security refers to data only being accessible through authorised channels. Finally if the user has been authenticated and has the required authorization then accounting needs to be done to be able to determine how the users action has changed the system.  

			\item \textbf{Justification} \\
				Security is a important aspect of any software product. In terms of information security, we are concerned about integrity, availability, confidentiality and non-repudiation in that order. 

				The reason we are most concerned about data integrity is that this data will be used to monitor and determine performance of researchers as well as assist in departmental strategic planning, which implies that the system must be available at all times to the heads of the research groups and the head of the department. 

				Following this, is the aspect of data confidentiality, as we want to ensure passwords of the users stay secure as well as the metadata of research papers. The storing of metadata and subsequent leaking of this metadata can lead to other researchers publishing and patenting ideas first.

				Finally, as this system is used to measure performance, it is important that non-repudiation of information is available, as researchers must be accountable for any information changes they make.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item System should be resistant to SQL injections.
					\item A user group hierarchy system should be used to manage user access rights.
					\item Authentication credentials such as username and password should not be stored on Android user device. A token based authentication approach should be utilized so that only tokens are stored on end user device, allowing for the easy revocation of device access if a device is lost. Available technologies, such as OAuth, should be utilized.
					\item Password hosting with a unique salt for each user should be used.
					\item A key derivation function should be used with passwords. 
					\item After N invalid attempts, account should be locked for M min, where N and M would be agreed upon customer and developer based on current best practices.
					\item Database access must require authentication.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Flexibility}
		\begin{enumerate}
			\item \textbf{Description} \\
				Flexibility refers to the ability of the system to be changed dynamically either by hot swapping certain components in a live system or by extending the system with some kind of plugin. 

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Maintainability}
		\begin{enumerate}
			\item \textbf{Description} \\
				The system is to be designed in such a way that it is easily updated, modified or extended by the client in the future. In order to achieve these requirements, design patterns and best practices such as coding style guides are normally used to ensure uniformity and modularity across the system.

			\item \textbf{Justification} \\
				Many systems require regular changes, not because they were poorly designed or implemented, but because of changes in external factors. For example we might need to update informations to meet the Computer Science laws and regulations.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item All code should be documented in the applicable language documentation framework, such as JavaDocs for a Java based system, DOxygen for a C/C++ based system, etc.
					\item A coding style guide/manual should be set up and associated with the project, such that all developers use similar coding styles and conventions, to allow for more readable code that is easier to maintain.
					\item System should be separated in distinct, concise and independent modules relating to separate concerns, to allow for easier maintenance.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Auditability/Monitorability}
		\begin{enumerate}
			\item \textbf{Description} \\
			The system is to be designed to be verbose and transparent in its workings, and to ensure maximum data security, to allow role players to have insights into how the system is used and how it may be improved. These requirements are achieved by making the maximum amount of relevant data available to authorized users, logging performance critical information, and by enforcing strict constraints on the data that is stored. 

			\item \textbf{Justification} \\
			This is an important process in Software Engineering, where all the informations must be correct so requiring all the developers to see who made changes and when so that consistency must be kept in order to keep the database accurate and reliable.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item Data in database should always be consistent. This implies that all data should adhere to constraints placed on the data by the data model, such as regex patterns, minimum and maximum length, non nullable fields, etc.
					\item No data should ever be deleted.
					\item It should always be possible to see which user created which objects at what time.
					\item It should always be possible to see which user last changed objects and at what time.
					\item An immutable log of user actions should be kept and should only be accessible by administrative staff.
					\item Logging of stack traces and crash analytics should be implemented in the mobile client, to ensure the developers can see to client reliability.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Integrability}
		\begin{enumerate}
			\item \textbf{Description} \\
				The system should allow for future external integration with other platforms such as security authentication providers, other external research meta-data databases etc.

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Cost}
		\begin{enumerate}
			\item \textbf{Description} \\
				The cost of the system entails any initial expenses as well as any ongoing expenses which the client may incur at some point. Such expenses arise from software licenses, external computing resources required as well as future maintenance of the system in terms of time.

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
				\begin{itemize}
					\item System should be cheap to operate, maintain and extend. If the quality and maturity of technologies available allow it, technologies used must be freely available/usable.
					\item As far as possible, open source compatible, mature technologies should be used, to ensure system stability as far as possible.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Usability}
		\begin{enumerate}
			\item \textbf{Description} \\
				Usability refers to ease with which humans, and to a lesser extent, servers, interact with the system in question. Usability can be measured in various ways such as using quantifiable scientific measures or more subjective measures with a key question point being if the API follows conventions and so on.

			\item \textbf{Justification} \\
				It is important that the new system is usable as it is a user-centric system. Ensuring that the system is usable will ensure that users capture accurate and correct information into the system which will for better performance and departmental strategic planning. As this system will also be used by parties outside of the Department of Computer Science of the University of Pretoria, it is important that the system conveys a professional image, as this will reflect on the image of the University of Pretoria. 

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item Android app and web client should support the full back-end API specifications.
					\item The user must be allowed to elect whether they would like their data to be available offline.
					\item Mobile client users should be able choose between downloading data over Wi-Fi or 3G.
				\end{itemize}
		\end{enumerate}

\subsection{Integration and access channel requirements}
\subsection{Architectural constraints}

\section{Architectural patterns or styles}
	\begin{itemize}
		\item \textbf{Authentication Enforcer Pattern} \\
		The authentication enforcer pattern is focused to provide a centralized managed authentication mechanism, to verify the identity of users and encapsulating the details of authentication. This patterns assist in removing security checks from business logic code, thereby providing cleaner, more robust and easier to maintain code.

		Further, since authentication is centralized, this pattern further allows changes to be easily implemented in terms of the authentication procedure, such as using a different authentication flow, or even mechanism, such as authenticating the user against an external provider.

		\item \textbf{Authorization Enforcer} \\
				Similar to the authentication enforcer pattern, this pattern provides a centralized managed authorization mechanism, thereby abstracting authorization code away from application code.  With this pattern, it assists the system in authorizing users, i.e. to determine whether the current user has the required roles or privileges to perform a certain action. All of the benefits referred to in the authentication enforcer pattern are also applicable here.

		\item \textbf{Client-Server Architectural Pattern}\\
				A network technology in which each computer connected on the network is either a server or client is called a client server architecture.
				\begin{enumerate}
					\item Servers: are powerful computers which are used to process the client requests.
					\item Client: is simply a computer connected on the network which is used to send request for some resources to the server.
				\end{enumerate}
				Requirement of client server: It models work in a networked environment therefore the processing of an application distributed between the client and the server.

				Function of client server: An interface/form is provided by the client to allow a user to request services of the user and to display the results the server returns.

		\item \textbf{Representational State Transfer (REST) Architectural Pattern}\\
				REST is an architecture pattern for designing networked applications. The idea is instead of using complex mechanisms such as SOAP, CORBA or RPC to connect between machines or to make calls between machines, simple HTTP is used.

				The Uniform interfaces which is combined of resource names and HTTP, GET, DELETE, POST, PUT.

				A REST service is:
				\begin{enumerate}
					\item Language-independent (C\# can communicate to Java, etc.),
					\item Can be used with firewalls,
					\item Platform-independent (MAC, Windows, UNIX) and,
					\item Standards-based (runs on top of HTTP)
				\end{enumerate}

		\item \textbf{Secure Data Logger Pattern} \\
				A requirement stated by the client is that the proposed system should contain a full audit trail functionality, which would allow administrators to view any action that executed by users, as well as the modification that execution had on the data.

				For this requirement the Secure Data Logger Security Pattern can be utilized. This pattern aims to log application system log to a secure tamper-proof log system, which would prevent users from modifying the audit trail. This pattern also goes further by ensuring the integrity of the log message, which can be achieved by various means, such as cryptographically signing the message, or encrypting the message before it is sent to the store.

				This pattern provides two important security features, depending on how the logging system, as well as the message are secured in the system.  The first protection, is that should a malicious user gain access to the logging system, they will be unable to use the data to plan further attacks on the system.  The second protection provided by this pattern, is that any modification of the log data will be detectable by administrators.

	\end{itemize}
\section{Architectural tactics or strategies}
 
\section{Reference architectures and frameworks}
 
\section{Access and integration channels}

\section{Technologies}
\subsection{Backend System}
\subsubsection{Programming Languages}
	\begin{itemize}
		\item Java\\
			Java is a class based, concurrent and object orientated programming language design to allow developers to write there code once and be able to run it on a multitude of different devices, by means of using a virtual machine environement to execute the code. As Java is a mature programming langauage a large eco-system exists which enable one to build quick, quality based, scalable and secure software engineered applications.
	\end{itemize}

\subsubsection{Frameworks}
		\begin{itemize}
			\item Spring Framework
				The Spring framework is an open source application and dependency injection framework, often used in favour or in addition to the Java Enterprise Edition system.
				
				The Spring framework, which is part of the larger Spring Project consists of several project which will be used in our application, namely
					\begin{itemize}
						\item Spring Boot
						\item Spring Cloud
						\item Spring Data
						\item Spring Security
						\item Spring Social
					\end{itemize}
			\item Hibernate ORM\\
				Hibernate ORM is an object relational mapper framework for Java, which allows the mapping of Java classes onto relational database tables. Hibernate provides various features, such as SQL generation, transaction management with cascade operations which can be used to ensure  referential integrity.
			\item Liquibase\\
				Liquibase is an open-source library which allows one to track, manage and apply database schema changes to relational object databases. In the way that git is used for source code, Liquibase is used for database schemas.  Liquibase supports a variety of database systems, allows for the tracking of database schema changes, rollback of database schama changes, database schema document generation as well as the ablity to confirm that the current database schema is consistent, by performing SQL and preconditions checks on existing live database systems.

				As part of software engineering best-practices of self documenting code, it is very difficult to achieve in database schemas, as the only indication of a schema change, is a possible change in source code version control system of a Plain Old Java Object (POJO). Further Liquibase has excellent integration with the chosen build system, namely Maven, and the reference architecture, namely the Spring framework. 
			\item SLF4J\\
				The Simple Logging Facade for Java aims to provide a language neutral Java Logging API with the help of a Facade design pattern, allowing the logging backend to be chosen at run-time by inspecting the Java classpath.
				
				Using SLF4J will allow us to deploy the application with a chosen logging framework, but will fulfill the quality requirements of flexability and extendability by allowing the client to change the logging framework to a more appropriate framework, if desired by the client.
			\item Apache Log4J\\
				We will be using the Apache Log4J logging framework as it allows full control over what log statements are output at arbitrary granularity.  Configuration of the system is available at run-time using external configuration files, fulfulling the quality requirements of flexability and auditability.
			\item Java Jersey\\
			Java Jersey provides RESTful web services for Java and is also a JAX-RS(JSR 311 \& JSR-339) reference implementation. Java Jersey as a reference implementation provides for fast and efficeint marshalling and unmarshalling of Plain Old Java Objects (POJOs) to JavaScript Object Notation (JSON) and eXtensible Markup Language representations which can be sent over the wire to RESTful clients, such as the to be implemented web and Android mobile client. 

			\item Swagger\\
				Swagger aims to provide a language neutral standard interface to assist both developers and machines to discover and interact with REST API's. 
				
				As part of self documenting code, Swagger uses JAX-RS annotations to generate the specification for the API and with various library plugins available, allows one to produce a standardised HTTP API documentation set, which is included with the Java deployment of the application.
		\end{itemize}

\subsubsection{Libraries}
	\begin{itemize}
		\item Apache FOP\\
			Apache FOP is an XSL-FO driven printer which can output to various file formats.  The client has indicated that they would like to produce PDF reports based on custom criterias, hence the use of an XSL-FO driven printer will allow for this. The reason that a lower level PDF print library was not used, is that the design of documents gets very complicated, which will hinder future flexability.
	\end{itemize}

\subsubsection{Database System}
	\begin{itemize}
		\item PostgreSQL\\
			PostgreSQL is an open source RDMS that is used to manage relational databases. As we will be using a NoSQL database for the backend, a big performance penalty is that traditional SQL queries are not available, which lowers performance in certain instances and can make retrieving certain data very difficult.  For this reason a modern approach is overlay one's NoSQL database with a SQL database system, allowing to gain the performace of NoSQL databases, but also allowing one to perform traditional based SQL statements on the data. 

			PostgreSQL provides this ability with its Forgein Data Wrappers, which we will be using, as we gain the benefit of mobile device synchronization with the performance increase of using a NoSQL database, while retaining the ability to query the data using traditional SQL statamenets based on user based queries.
		\item Couchbase Server\\
			Couchbase Server is an open source, distributed, enterprise NoSQL document based database system, powering mission critical systems of some of the largest technology companies today. Couchbase has excellant performance and scalability options and for these reasons was selected as the backend database. Further as the Couchbase product line support native mobile client synchronization, we selected Couchbase as this will allow us to provide the client  with mobile offline access and speeding up development, as a synchronization framework doesn't need to be built.
		\item Couchbase Sync Gateway\\
			Couchbase Sync Gateway is the internet facing intermediate server providing and enabling the synchronization framework of the Couchbase product line, and as such is not a traditional database management system.  However it is needed as part of the backend system and hence included under the database system section.
	\end{itemize}

\subsubsection{Operating System}
	\begin{itemize}
		\item The client has indicated the target system for the backend is a server running a Linux operating system. As we are developing the backend system in Java, this will ensure the system will be able to run on the given Linux server provided the correct Java JDK is available. Further by using Java, we ensure the client has the possibility in future to change the underlying operating system of the server, and still remain comptable with the application.
	\end{itemize}
\subsubsection{Dependency Management and Build Tools}
	\begin{itemize}
		\item Maven\\
			Maven is an XML declaritive based build tool for java projects which also includes a dependency management system to manage dependencies used within the given Java project.

			By using a build tool such as Maven, we ensure that upon compilation, the build tool will check dependencies, run unit tests and compile and produce a sane project passing all needed quality requirements.
	\end{itemize}

\subsection{Web Interface}
\subsubsection{Programming Languages}
\subsubsection{Frameworks}
	\begin{itemize}
	\item AngularJS\\
		AngularJS is a JavaScript web application framework maintained by Google and volunteers, provding developers with a Model-View-Controller(MVC) and Model-View-ViewModel (MVVM) architectures to developer Single Page Applications (SPA). As the community has grown around AngularJS various plugins and components have been provided which eases the developement of rich internet applications, espesically with excellant support from AngularJS itself to support RESTful applications.

		The reason that AngularJS was chosen, is that it is a mature code base, with a large support community and which modern software engineering tools support to ensure a quality application is delivered to the end client. This allows one to do unit testing with ease, allow for the integration of a frontend end dependency management system such as bower and using modern build tools such as Grunt, in the end deliver a fast, stable, secure and efficient modern single page application.
	\end{itemize}

\subsubsection{Libraries}
	\begin{itemize}
		\item Modernizr\\
			Modernizr is a JavaScript(JS) library to provide developers a stable, consistent and standardized manner of feature detecion in browers. Based on the fact we will be targeting our application to modern HTML5 based browser, we need to utilize a feature detection toolkit in order to be able to gracefully degrade the website for users of older browsers.
		\item Karma\\
			Karma is a test runner for JavaScript development and being framework agnostic allows developers to select there own framework to be used with the testing. As we need to ensure that the system remains stable, we will be using Karma with Jasmine as the test framework for the frontend JavaScript unit testing.
		\item Jasmine\\
			Jasmine is a behavious driven testing framework for JavaScript with the advantage of not requiring further 3rd party libraries or needing a fully functional DOM to do the testing against.
		\item Gatling\\
			Gatling is a load testing framework used to test, measure, analyze and report on the performance of web services, allow one to ensure that a given project would be able to scale under increased load pressure.

			As scability is a requirement for this project, especially during month end peak load times, it is of the utmost importance to ensure that the system is scalable under this increased load. By using a testing framework like Gatling one will be able to measure quantitatively how scalable the system is.
	\end{itemize}

\subsubsection{Database System}
	\begin{itemize}
		\item Since we are utilizing a token based authenication mechanism, we need to store the access and refresh tokens on the client side, as the access token should accompany each request to the backend system.  The refresh token is also needed to refresh the access token, should the client continue to work longer than the period for which the access token is valid. We need to consider both newer and older client browsers, and hence we will utlize the following two persistance technologies:
		\begin{itemize}
			\item HTML5 Local Storage\\
				For clients who are utilizing an HTML 5 capable browser with local storage we will be using the newer and safer local storage ability provided by the be browser to store the token temporary. Upon logout of the backend system, these token will be earsed on the client side.
			\item Cookies\\
				To allow clients who are using and older browser to still use the system, we will store the token in cookies on the client system, which will be erased upon logout from the backend system, in order to increase security,
		\end{itemize}
	\end{itemize}

\subsubsection{Operating System}
	\begin{itemize}
		\item Device Operating System
			As we will be developing a SPA which will be running in the context of a web browser, the underlying device operating system is independant of the application, and hence we will be able to support any operating system which provides the required browser.
		\item Web Browser
			As we will be using AngularJS to build a SPA, we will be supporting the following browsers
		\begin{itemize}
			\item Google Chrome
			\item Mozilla Firefox
			\item Microsoft Internet Explorer 8,9 \& 10
			\item Microsoft Edge
			\item Apple Safari
		\end{itemize}
	\end{itemize}

\subsubsection{Dependency Management and Build Tools}
	\begin{itemize}
		\item Bower\\
			Bower is a package manager for frontend developement, allowing developers to manage HTML, JS, CSS and font 3rd party libraries.  It further allows for the installation of the correct versions of libraries with their corresponding dependencies. This allows developers to more cleanly determine on what libraries there projects depend and allows for better repository management. The reason is that most modern frontend libraries are already found in source version control repositories, and to add library source code to your own repository, not only inflates the repository size but doesn't allow for clean trakcing of the how the ibrary code itself has evolved over time.

		\item Grunt\\
			Grunt is a a JavaScript build tool that assist developers in automating reptitve tasks. Grunt being written in JavaScript makes the build system extremely flexable and allows the system to be adapted for any task required by developers, which has lead to the large amount of plugins being written for the build system.

			The reason for using grunt for the web development build is we require the following repetive tasks to be completed each time the web frontend needs deployment:
			\begin{itemize}
				\item Minification of CSS and JS source files.
				\item Concatenation and versioning in the filename of CSS and JS files.
				\item Removing of unneed CSS styles to decrease page loading time.
				\item Autowiring of Bower dependency libraries into the web frontend.
				\item Running of CSSLint and JSLint utilities on corresponding CSS and JS file to ensure the files are correct.
				\item Running of Karma JS unit tests to ensure JS functions are correct.
				\item Minification and compression on image files to ensure we decrease page loading time and increase user expierence.
				\item Running of Gatling stress testing to ensure changes made to frontend doesn't impact on the quality requirement for scalability and system performance.
			\end{itemize}
	\end{itemize}

\subsection{Android Client}
\subsubsection{Programming Languages}
	\begin{itemize}
		\item Java\\
			We will be writing a native Android application and hence we are required by the constraints of the Android system to utilize the Java programming language. In terms of Android using Java, Android relies heavy on the following Java concepts:
			\begin{itemize}
				\item Platform Independence\\
					After the developers have developed there applications in a selected programming language, the programmer often needs to compile there source code. The process of compiling source code is the conversion of the code written by the developer into a language that a certain device can understand. 
					
					It is important to note that different devices, understand different machine level langauges, and as such the developer is often forced to recompile the application for different devices understanding different machine languages. Using Java, Java source code is converted into a language called "bytecode", which is then interpreted and exectued by the Java Virtual Machine (JVM), which operates much like a physical CPU does.
					
					Using this ability of Java, it allows developers to compile there application once, and have it available on multiple different devices, by not needing to worry what machine language powers the given device. This gives developers the ability for the application to run on Android phones, tablets to even the latest toaster, car or water-bottle powered by Android.
					
				\item Secure Virtual Machines\\
					Since Java execute in a virtual machine, Android has taken advantage of this ability, and runs each application in its own virtual machine as seperate Linux users. In this way Android abstracts the execution of machine language away from the physical hardware, into a virtual machine which encapsulates and contains the bytecode and which can be more easily managed should applications not fulfill certain constraints, such as consuming too much power.
				\end{itemize}
		\item eXtensible Markup Language (XML)\\
			Android makes extensive use of XML to assist it in creating user screens in a process called inflation, storing string literals which allows for internationalization based on user preferences, and the selection of media such as image, video and audio based on the devices capablities, such as screen resolution, avaible decoders etc.
	\end{itemize}
	
\subsubsection{Frameworks}
	\begin{itemize}
		\item Spring for Android\\
		Spring for Android is a framework bringing selected capablities from the Spring framework to the Android platform, allowing for faster, cleaner and more efficent developement of Andriod applications. Capabilities of Spring for Android include:
		\begin{itemize}
			\item A RESTful client with full Hypermedia as the Engine of Application State (HATEOAS) capability
			\item Authentication support which includes OAuth 1.0 and 2.0 capability, allow for token based authentication.
		\end{itemize}
	\end{itemize}

\subsubsection{Libraries}
	\begin{itemize}
		\item Android Butterknife\\
		Butterknife for Android brings Dependency Injection (DI) capability to Android's view system, allowing for cleaner and faster code. This is achieved by using Java annotations to bind visual components to corresponding Android Java components, thereby eliminating the need for poluting production source code with the infamous Android findViewById() method, which itself uses slow Java reflection to accomplish its task. Butterknife on the other hand produces code at compile time to assist in the lookup process.
	\end{itemize}

\subsubsection{Database System}
	\begin{itemize}
		\item Couchbase Mobile\\
		Couchbase Mobile is a NoSQL database system supporting all major mobile platforms, providing fast and consistent access to data, with or without a network connection. The Couchbase Mobile system consists of three key components:
		\begin{itemize}
			\item Couchbase Lite\\
			A mobile orientated NoSQL database allowing for low latency read/write access of data.
			\item Couchbase Sync Gateway\\
			An internet facing component, interfacing between mobile clients and the backend system to achieve secure synchronization of data.
			\item Couchbase Server\\
			A scalable, high performance, cluster based and enterprise based NoSQL database server providing NoSQL database functionality, with traditional based Structed Query Language functionality.
		\end{itemize}

		\item Utilizing a complete turn-around database system like Couchbase Mobile, will allow for the delivery of a fast and consistent user expierence, with the additional benefit of providing the mobile client with offline access and capability to view and edit selected data. 
	\end{itemize}

\subsubsection{Operating System}
	\begin{itemize}
		\item As the mobile will be built for Android devices, it implies that the target operating system will be the Android operating system. We will be targeting Android version 4.1+ devices.
	\end{itemize}
\subsubsection{Dependency Management and Build Tools}



\end{document}
