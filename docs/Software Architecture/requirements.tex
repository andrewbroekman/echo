\documentclass[a4paper,10pt]{article}

\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[all]{hypcap}
\usepackage{tabu}
\usepackage[title,titletoc,toc]{appendix}
\usepackage[english]{babel}
\usepackage{fontspec}
\usepackage[style=authoryear,backend=biber,sorting=nyt,dashed=false,urldate=long,abbreviate=false]{biblatex}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{microtype}

\addbibresource{references.bib}

\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{\bfseries Software Architecture Specification}
\lfoot{Team Echo}
\cfoot{COS301 Software Engineering}
\rfoot{Page \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\frenchspacing

\title{\includegraphics[width=12cm]{Eeufeeslogo.jpg} \\
       Software Architecture \\
       Research Paper Management System \\
       \vspace{0.5cm}
       University of Pretoria \\
       \vspace{1.0cm}
       }

\date{} 
\author{Team Echo\\
	\vspace{0.5cm} \\
	\begin{tabu} to \textwidth { X[l] X[l]}
		\hline
		\textbf{Surname, First Name (Initial)}	& \textbf{Student Number}	\\ \hline \hline
		Bode, Elizabeth (EF)			& 14310156		\\ \hline
		Bondjobo, Jocelyn (JM)		& 13232852		\\ \hline
		Broekman, Andrew (A)		& 11089777		\\ \hline
		Loreggian, Fabio (FR)			& 14040426		\\ \hline
		Schutte, Gerome (GC)		& 12031519		\\ \hline
		Sefako, Motsitsiripe (MG)		& 12231097		\\ \hline
		Singh, Emilio (E)			& 14006512		\\ \hline
		\hline
	\end{tabu}}

\DefineBibliographyStrings{english}{%
urlseen = {\mbox{Accessed} on},
urlfrom = {[Online]},
in = {In},
}
\DeclareFieldFormat{url}{\bibstring{urlfrom}\space\url{#1}}
\DeclareFieldFormat{urldate}{\addcomma\space[\bibstring{urlseen}\space#1]}
\addto\captionsenglish{
  \renewcommand{\contentsname}
    {Table of Contents}
}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\tableofcontents
\clearpage

\newpage
\pagenumbering{arabic}

\section{Architecture requirements}
\subsection{Architectural scope}
\subsection{Quality requirements}
	\subsubsection{Performance}
		\begin{enumerate}
			\item \textbf{Description} \\
				Application performance can be defined as the amount of work that can be accomplished by an application in question in a measured time interval. The time interval is normally measured in seconds, where the amount of work can be defined as the throughput, latency or data transmission time.
				\begin{itemize}
					\item \textbf{Throughput} \\
					The number of requests and responses which can be processed by the system in a given time interval.
					\item \textbf{Latency} \\
					A time interval measured as the time it takes to service a request.
					\item \textbf{Data transmission time} \\
					The time it takes to transmit a request to the server from a client or a response from the server to the client. This is heavily influenced by the size of the request, as well as the quality of the network medium.
				\end{itemize}

				The aim for this system, is to increase the throughput and decrease the latency. As the developer has no control over the network medium used, he/she must aim for a minimal request and response payload as to decrease the data transmission time.

			\item \textbf{Justification} \\
				The current system suffers from performance issues, and hence, it is important for this new system to address these issues adequately. Our aim for this system is to increase throughput, decrease latency and data transmission time. This will ensure we have a system that is responsive at all times, including peak times and delivers an excellent user experience.

			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Reliability}
		\begin{enumerate}
			\item \textbf{Description} \\
				The design of this system is largely based on the fact that the current system used by the client is not reliable and suffers from system crashes and data loss. The newly designed system needs to be accessible from both inside University of Pretoria campuses as well as from other networks, especially on other campuses on the TENET network. The system should be reliable in both its accessibility and in the data that the system will use to calculate contributor metrics. 

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Scalability}
		\begin{enumerate}
			\item \textbf{Description} \\
				Scalability refers to the application in question's ability to handle an above normal workload for extended time periods and the mechanisms employed to facilitate this. The client has specified minimum conditions under which the system needs to function. However, the client has indicated that due to the business requirements, the system will experience higher workloads during the end of the month.

			\item \textbf{Justification} \\
				The system needs Scalability because it needs to support 10 research groups, with 100 members each working with 50 concurrent users. But these requirements may increase in future and hence the system should be able to handle additional loads.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item The system should be able to handle 10 research groups with each research group containing 100 members.
					\item The system should be able to facilitate 50 concurrent user sessions at any time.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Security}
		\begin{enumerate}
			\item \textbf{Description} \\
				Security in application software refers to authentication, authorization, data security and accounting. Authentication refers to the systems' ability to provide a way of identifying a user, normally with a combination of a user name and password, or by using access tokens. Authorization refers to the systems' ability to determine whether the user in question has the required authority to execute certain commands or tasks. Data security refers to data only being accessible through authorised channels. Finally if the user has been authenticated and has the required authorization then accounting needs to be done to be able to determine how the users action has changed the system.  

			\item \textbf{Justification} \\
				Security is a important aspect of any software product. In terms of information security, we are concerned about integrity, availability, confidentiality and non-repudiation in that order. 

				The reason we are most concerned about data integrity is that this data will be used to monitor and determine performance of researchers as well as assist in departmental strategic planning, which implies that the system must be available at all times to the heads of the research groups and the head of the department. 

				Following this, is the aspect of data confidentiality, as we want to ensure passwords of the users stay secure as well as the metadata of research papers. The storing of metadata and subsequent leaking of this metadata can lead to other researchers publishing and patenting ideas first.

				Finally, as this system is used to measure performance, it is important that non-repudiation of information is available, as researchers must be accountable for any information changes they make.

			\item \textbf{Requirements}\\
				\item System should be resistant to SQL injections.
				\item A user group hierarchy system should be used to manage user access rights.
				\item Authentication credentials such as username and password should not be stored on Android user device. A token based authentication approach should be utilized so that only tokens are stored on end user device, allowing for the easy revocation of device access if a device is lost. Available technologies, such as OAuth, should be utilized.
		\end{enumerate}

	\subsubsection{Flexibility}
		\begin{enumerate}
			\item \textbf{Description} \\
				Flexibility refers to the ability of the system to be changed dynamically either by hot swapping certain components in a live system or by extending the system with some kind of plugin. 

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Maintainability}
		\begin{enumerate}
			\item \textbf{Description} \\
				The system is to be designed in such a way that it is easily updated, modified or extended by the client in the future. In order to achieve these requirements, design patterns and best practices such as coding style guides are normally used to ensure uniformity and modularity across the system.

			\item \textbf{Justification} \\
				Many systems require regular changes, not because they were poorly designed or implemented, but because of changes in external factors. For example we might need to update informations to meet the Computer Science laws and regulations.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item All code should be documented in the applicable language documentation framework, such as JavaDocs for a Java based system, DOxygen for a C/C++ based system, etc.
					\item A coding style guide/manual should be set up and associated with the project, such that all developers use similar coding styles and conventions, to allow for more readable code that is easier to maintain.
					\item System should be separated in distinct, concise and independent modules relating to separate concerns, to allow for easier maintenance.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Auditability/Monitorability}
		\begin{enumerate}
			\item \textbf{Description} \\
			The system is to be designed to be verbose and transparent in its workings, and to ensure maximum data security, to allow role players to have insights into how the system is used and how it may be improved. These requirements are achieved by making the maximum amount of relevant data available to authorized users, logging performance critical information, and by enforcing strict constraints on the data that is stored. 

			\item \textbf{Justification} \\
			This is an important process in Software Engineering, where all the informations must be correct so requiring all the developers to see who made changes and when so that consistency must be kept in order to keep the database accurate and reliable.

			\item \textbf{Requirements}\\
				\begin{itemize}
					\item Data in database should always be consistent. This implies that all data should adhere to constraints placed on the data by the data model, such as regex patterns, minimum and maximum length, non nullable fields, etc.
					\item No data should ever be deleted.
					\item It should always be possible to see which user created which objects at what time.
					\item It should always be possible to see which user last changed objects and at what time.
					\item An immutable log of user actions should be kept and should only be accessible by administrative staff.
					\item Logging of stack traces and crash analytics should be implemented in the mobile client, to ensure the developers can see to client reliability.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Integrability}
		\begin{enumerate}
			\item \textbf{Description} \\
				The system should allow for future external integration with other platforms such as security authentication providers, other external research meta-data databases etc.

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
		\end{enumerate}

	\subsubsection{Cost}
		\begin{enumerate}
			\item \textbf{Description} \\
				The cost of the system entails any initial expenses as well as any ongoing expenses which the client may incur at some point. Such expenses arise from software licenses, external computing resources required as well as future maintenance of the system in terms of time.

			\item \textbf{Justification} \\
			\item \textbf{Requirements}\\
				\begin{itemize}
					\item System should be cheap to operate, maintain and extend. If the quality and maturity of technologies available allow it, technologies used must be freely available/usable.
					\item As far as possible, open source compatible, mature technologies should be used, to ensure system stability as far as possible.
				\end{itemize}
		\end{enumerate}

	\subsubsection{Usability}
		\begin{enumerate}
			\item \textbf{Description} \\
				Usability refers to ease with which humans, and to a lesser extent, servers, interact with the system in question. Usability can be measured in various ways such as using quantifiable scientific measures or more subjective measures with a key question point being if the API follows conventions and so on.

			\item \textbf{Justification} \\
				It is important that the new system is usable as it is a user-centric system. Ensuring that the system is usable will ensure that users capture accurate and correct information into the system which will for better performance and departmental strategic planning. As this system will also be used by parties outside of the Department of Computer Science of the University of Pretoria, it is important that the system conveys a professional image, as this will reflect on the image of the University of Pretoria. 

			\item \textbf{Requirements}\\
		\end{enumerate}

\subsection{Integration and access channel requirements}
\subsection{Architectural constraints}

\section{Architectural patterns or styles}
	\begin{itemize}
		\item \textbf{Authentication Enforcer Pattern} \\
		The authentication enforcer pattern is focused to provide a centralized managed authentication mechanism, to verify the identity of users and encapsulating the details of authentication. This patterns assist in removing security checks from business logic code, thereby providing cleaner, more robust and easier to maintain code.

		Further, since authentication is centralized, this pattern further allows changes to be easily implemented in terms of the authentication procedure, such as using a different authentication flow, or even mechanism, such as authenticating the user against an external provider.

		\item \textbf{Authorization Enforcer} \\
				Similar to the authentication enforcer pattern, this pattern provides a centralized managed authorization mechanism, thereby abstracting authorization code away from application code.  With this pattern, it assists the system in authorizing users, i.e. to determine whether the current user has the required roles or privileges to perform a certain action. All of the benefits referred to in the authentication enforcer pattern are also applicable here.

		\item \textbf{Representational State Transfer (REST) Architectural Pattern}\\
				REST is an architecture pattern for designing networked applications. The idea is instead of using complex mechanisms such as SOAP, CORBA or RPC to connect between machines or to make calls between machines, simple HTTP is used.

				The Uniform interfaces which is combined of resource names and HTTP, GET, DELETE, POST, PUT.

				A REST service is:
				\begin{enumerate}
					\item Language-independent (C\# can communicate to Java, etc.),
					\item Can be used with firewalls,
					\item Platform-independent (MAC, Windows, UNIX) and,
					\item Standards-based (runs on top of HTTP)
				\end{enumerate}

		\item \textbf{Client-Server Architectural Pattern}\\
				A network technology in which each computer connected on the network is either a server or client is called a client server architecture.
				\begin{enumerate}
					\item Servers: are powerful computers which are used to process the client requests.
					\item Client: is simply a computer connected on the network which is used to send request for some resources to the server.
				\end{enumerate}
				Requirement of client server: It models work in a networked environment therefore the processing of an application distributed between the client and the server.

				Function of client server: An interface/form is provided by the client to allow a user to request services of the user and to display the results the server returns.

		\item \textbf{Secure Data Logger Pattern} \\
				A requirement stated by the client is that the proposed system should contain a full audit trail functionality, which would allow administrators to view any action that executed by users, as well as the modification that execution had on the data.

				For this requirement the Secure Data Logger Security Pattern can be utilized. This pattern aims to log application system log to a secure tamper-proof log system, which would prevent users from modifying the audit trail. This pattern also goes further by ensuring the integrity of the log message, which can be achieved by various means, such as cryptographically signing the message, or encrypting the message before it is sent to the store.

				This pattern provides two important security features, depending on how the logging system, as well as the message are secured in the system.  The first protection, is that should a malicious user gain access to the logging system, they will be unable to use the data to plan further attacks on the system.  The second protection provided by this pattern, is that any modification of the log data will be detectable by administrators.

	\end{itemize}
\section{Architectural tactics or strategies}
 
\section{Reference architectures and frameworks}
 
\section{Access and integration channels}

\section{Technologies}
\subsection{Backend System}
\subsubsection{Programming Languages}
\subsubsection{Frameworks}
\subsubsection{Libraries}
\subsubsection{Database System}
\subsubsection{Operating System}
\subsubsection{Dependency Management and Build Tools}

\subsection{Web Interface}
\subsubsection{Programming Languages}
\subsubsection{Frameworks}
	\begin{itemize}
	\item AngularJS\\
		AngularJS is a JavaScript web application framework maintained by Google and volunteers, provding developers with a Model-View-Controller(MVC) and Model-View-ViewModel (MVVM) architectures to developer Single Page Applications (SPA). As the community has grown around AngularJS various plugins and components have been provided which eases the developement of rich internet applications, espesically with excellant support from AngularJS itself to support RESTful applications.

		The reason that AngularJS was chosen, is that it is a mature code base, with a large support community and which modern software engineering tools support to ensure a quality application is delivered to the end client. This allows one to do unit testing with ease, allow for the integration of a frontend end dependency management system such as bower and using modern build tools such as Grunt, in the end deliver a fast, stable, secure and efficient modern single page application.
	\end{itemize}

\subsubsection{Libraries}
	\begin{itemize}
		\item Modernizr\\
			Modernizr is a JavaScript(JS) library to provide developers a stable, consistent and standardized manner of feature detecion in browers. Based on the fact we will be targeting our application to modern HTML5 based browser, we need to utilize a feature detection toolkit in order to be able to gracefully degrade the website for users of older browsers.
		\item Karma\\
			Karma is a test runner for JavaScript development and being framework agnostic allows developers to select there own framework to be used with the testing. As we need to ensure that the system remains stable, we will be using Karma with Jasmine as the test framework for the frontend JavaScript unit testing.
		\item Jasmine\\
			Jasmine is a behavious driven testing framework for JavaScript with the advantage of not requiring further 3rd party libraries or needing a fully functional DOM to do the testing against.
		\item Gatling\\
			Gatling is a load testing framework used to test, measure, analyze and report on the performance of web services, allow one to ensure that a given project would be able to scale under increased load pressure.

			As scability is a requirement for this project, especially during month end peak load times, it is of the utmost importance to ensure that the system is scalable under this increased load. By using a testing framework like Gatling one will be able to measure quantitatively how scalable the system is.
	\end{itemize}

\subsubsection{Database System}
	\begin{itemize}
		\item Since we are utilizing a token based authenication mechanism, we need to store the access and refresh tokens on the client side, as the access token should accompany each request to the backend system.  The refresh token is also needed to refresh the access token, should the client continue to work longer than the period for which the access token is valid. We need to consider both newer and older client browsers, and hence we will utlize the following two persistance technologies:
		\begin{itemize}
			\item HTML5 Local Storage\\
				For clients who are utilizing an HTML 5 capable browser with local storage we will be using the newer and safer local storage ability provided by the be browser to store the token temporary. Upon logout of the backend system, these token will be earsed on the client side.
			\item Cookies\\
				To allow clients who are using and older browser to still use the system, we will store the token in cookies on the client system, which will be erased upon logout from the backend system, in order to increase security,
		\end{itemize}
	\end{itemize}

\subsubsection{Operating System}
	\begin{itemize}
		\item Device Operating System
			As we will be developing a SPA which will be running in the context of a web browser, the underlying device operating system is independant of the application, and hence we will be able to support any operating system which provides the required browser.
		\item Web Browser
			As we will be using AngularJS to build a SPA, we will be supporting the following browsers
		\begin{itemize}
			\item Google Chrome
			\item Mozilla Firefox
			\item Microsoft Internet Explorer 8,9 \& 10
			\item Microsoft Edge
			\item Apple Safari
		\end{itemize}
	\end{itemize}

\subsubsection{Dependency Management and Build Tools}
	\begin{itemize}
		\item Bower\\
			Bower is a package manager for frontend developement, allowing developers to manage HTML, JS, CSS and font 3rd party libraries.  It further allows for the installation of the correct versions of libraries with their corresponding dependencies. This allows developers to more cleanly determine on what libraries there projects depend and allows for better repository management. The reason is that most modern frontend libraries are already found in source version control repositories, and to add library source code to your own repository, not only inflates the repository size but doesn't allow for clean trakcing of the how the ibrary code itself has evolved over time.

		\item Grunt\\
			Grunt is a a JavaScript build tool that assist developers in automating reptitve tasks. Grunt being written in JavaScript makes the build system extremely flexable and allows the system to be adapted for any task required by developers, which has lead to the large amount of plugins being written for the build system.

			The reason for using grunt for the web development build is we require the following repetive tasks to be completed each time the web frontend needs deployment:
			\begin{itemize}
				\item Minification of CSS and JS source files.
				\item Concatenation and versioning in the filename of CSS and JS files.
				\item Removing of unneed CSS styles to decrease page loading time.
				\item Autowiring of Bower dependency libraries into the web frontend.
				\item Running of CSSLint and JSLint utilities on corresponding CSS and JS file to ensure the files are correct.
				\item Running of Karma JS unit tests to ensure JS functions are correct.
				\item Minification and compression on image files to ensure we decrease page loading time and increase user expierence.
				\item Running of Gatling stress testing to ensure changes made to frontend doesn't impact on the quality requirement for scalability and system performance.
			\end{itemize}
	\end{itemize}

\subsection{Android Client}
\subsubsection{Programming Languages}
	\begin{itemize}
		\item Java\\
			We will be writing a native Android application and hence we are required by the constraints of the Android system to utilize the Java programming language. In terms of Android using Java, Android relies heavy on the following Java concepts:
			\begin{itemize}
				\item Platform Independence\\
					After the developers have developed there applications in a selected programming language, the programmer often needs to compile there source code. The process of compiling source code is the conversion of the code written by the developer into a language that a certain device can understand. 
					
					It is important to note that different devices, understand different machine level langauges, and as such the developer is often forced to recompile the application for different devices understanding different machine languages. Using Java, Java source code is converted into a language called "bytecode", which is then interpreted and exectued by the Java Virtual Machine (JVM), which operates much like a physical CPU does.
					
					Using this ability of Java, it allows developers to compile there application once, and have it available on multiple different devices, by not needing to worry what machine language powers the given device. This gives developers the ability for the application to run on Android phones, tablets to even the latest toaster, car or water-bottle powered by Android.
					
				\item Secure Virtual Machines\\
					Since Java execute in a virtual machine, Android has taken advantage of this ability, and runs each application in its own virtual machine as seperate Linux users. In this way Android abstracts the execution of machine language away from the physical hardware, into a virtual machine which encapsulates and contains the bytecode and which can be more easily managed should applications not fulfill certain constraints, such as consuming too much power.
				\end{itemize}
		\item eXtensible Markup Language (XML)\\
			Android makes extensive use of XML to assist it in creating user screens in a process called inflation, storing string literals which allows for internationalization based on user preferences, and the selection of media such as image, video and audio based on the devices capablities, such as screen resolution, avaible decoders etc.
	\end{itemize}
	
\subsubsection{Frameworks}
	\begin{itemize}
		\item Spring for Android\\
		Spring for Android is a framework bringing selected capablities from the Spring framework to the Android platform, allowing for faster, cleaner and more efficent developement of Andriod applications. Capabilities of Spring for Android include:
		\begin{itemize}
			\item A RESTful client with full Hypermedia as the Engine of Application State (HATEOAS) capability
			\item Authentication support which includes OAuth 1.0 and 2.0 capability, allow for token based authentication.
		\end{itemize}
	\end{itemize}

\subsubsection{Libraries}
	\begin{itemize}
		\item Android Butterknife\\
		Butterknife for Android brings Dependency Injection (DI) capability to Android's view system, allowing for cleaner and faster code. This is achieved by using Java annotations to bind visual components to corresponding Android Java components, thereby eliminating the need for poluting production source code with the infamous Android findViewById() method, which itself uses slow Java reflection to accomplish its task. Butterknife on the other hand produces code at compile time to assist in the lookup process.
	\end{itemize}

\subsubsection{Database System}
	\begin{itemize}
		\item Couchbase Mobile\\
		Couchbase Mobile is a NoSQL database system supporting all major mobile platforms, providing fast and consistent access to data, with or without a network connection. The Couchbase Mobile system consists of three key components:
		\begin{itemize}
			\item Couchbase Lite\\
			A mobile orientated NoSQL database allowing for low latency read/write access of data.
			\item Couchbase Sync Gateway\\
			An internet facing component, interfacing between mobile clients and the backend system to achieve secure synchronization of data.
			\item Couchbase Server\\
			A scalable, high performance, cluster based and enterprise based NoSQL database server providing NoSQL database functionality, with traditional based Structed Query Language functionality.
		\end{itemize}

		\item Utilizing a complete turn-around database system like Couchbase Mobile, will allow for the delivery of a fast and consistent user expierence, with the additional benefit of providing the mobile client with offline access and capability to view and edit selected data. 
	\end{itemize}

\subsubsection{Operating System}
\subsubsection{Dependency Management and Build Tools}



\end{document}
